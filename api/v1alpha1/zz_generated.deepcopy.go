//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by hand (mimics controller-gen output). DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// --- AgentRun ---

func (in *AgentRun) DeepCopyInto(out *AgentRun) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *AgentRun) DeepCopy() *AgentRun {
	if in == nil {
		return nil
	}
	out := new(AgentRun)
	in.DeepCopyInto(out)
	return out
}

func (in *AgentRun) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *AgentRunList) DeepCopyInto(out *AgentRunList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AgentRun, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *AgentRunList) DeepCopy() *AgentRunList {
	if in == nil {
		return nil
	}
	out := new(AgentRunList)
	in.DeepCopyInto(out)
	return out
}

func (in *AgentRunList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *AgentRunSpec) DeepCopyInto(out *AgentRunSpec) {
	*out = *in
	out.Model = in.Model
	if in.Parent != nil {
		in, out := &in.Parent, &out.Parent
		*out = new(ParentRunRef)
		**out = **in
	}
	if in.Sandbox != nil {
		in, out := &in.Sandbox, &out.Sandbox
		*out = new(AgentRunSandboxSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Skills != nil {
		in, out := &in.Skills, &out.Skills
		*out = make([]SkillRef, len(*in))
		copy(*out, *in)
	}
	if in.ToolPolicy != nil {
		in, out := &in.ToolPolicy, &out.ToolPolicy
		*out = new(ToolPolicySpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Timeout != nil {
		in, out := &in.Timeout, &out.Timeout
		*out = new(metav1.Duration)
		**out = **in
	}
}

func (in *AgentRunSpec) DeepCopy() *AgentRunSpec {
	if in == nil {
		return nil
	}
	out := new(AgentRunSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *AgentRunStatus) DeepCopyInto(out *AgentRunStatus) {
	*out = *in
	if in.StartedAt != nil {
		in, out := &in.StartedAt, &out.StartedAt
		*out = (*in).DeepCopy()
	}
	if in.CompletedAt != nil {
		in, out := &in.CompletedAt, &out.CompletedAt
		*out = (*in).DeepCopy()
	}
	if in.ExitCode != nil {
		in, out := &in.ExitCode, &out.ExitCode
		*out = new(int32)
		**out = **in
	}
	if in.TokenUsage != nil {
		in, out := &in.TokenUsage, &out.TokenUsage
		*out = new(TokenUsage)
		**out = **in
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *AgentRunStatus) DeepCopy() *AgentRunStatus {
	if in == nil {
		return nil
	}
	out := new(AgentRunStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ParentRunRef) DeepCopyInto(out *ParentRunRef) {
	*out = *in
}

func (in *ParentRunRef) DeepCopy() *ParentRunRef {
	if in == nil {
		return nil
	}
	out := new(ParentRunRef)
	in.DeepCopyInto(out)
	return out
}

func (in *TokenUsage) DeepCopyInto(out *TokenUsage) {
	*out = *in
}

func (in *TokenUsage) DeepCopy() *TokenUsage {
	if in == nil {
		return nil
	}
	out := new(TokenUsage)
	in.DeepCopyInto(out)
	return out
}

func (in *ModelSpec) DeepCopyInto(out *ModelSpec) {
	*out = *in
}

func (in *ModelSpec) DeepCopy() *ModelSpec {
	if in == nil {
		return nil
	}
	out := new(ModelSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *AgentRunSandboxSpec) DeepCopyInto(out *AgentRunSandboxSpec) {
	*out = *in
	if in.SecurityContext != nil {
		in, out := &in.SecurityContext, &out.SecurityContext
		*out = new(SandboxSecurityContext)
		(*in).DeepCopyInto(*out)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(ResourceSpec)
		(*in).DeepCopyInto(*out)
	}
}

func (in *AgentRunSandboxSpec) DeepCopy() *AgentRunSandboxSpec {
	if in == nil {
		return nil
	}
	out := new(AgentRunSandboxSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SandboxSecurityContext) DeepCopyInto(out *SandboxSecurityContext) {
	*out = *in
	if in.Capabilities != nil {
		in, out := &in.Capabilities, &out.Capabilities
		*out = new(CapabilitiesSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.SeccompProfile != nil {
		in, out := &in.SeccompProfile, &out.SeccompProfile
		*out = new(SeccompProfileSpec)
		**out = **in
	}
}

func (in *SandboxSecurityContext) DeepCopy() *SandboxSecurityContext {
	if in == nil {
		return nil
	}
	out := new(SandboxSecurityContext)
	in.DeepCopyInto(out)
	return out
}

func (in *CapabilitiesSpec) DeepCopyInto(out *CapabilitiesSpec) {
	*out = *in
	if in.Drop != nil {
		in, out := &in.Drop, &out.Drop
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

func (in *CapabilitiesSpec) DeepCopy() *CapabilitiesSpec {
	if in == nil {
		return nil
	}
	out := new(CapabilitiesSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SeccompProfileSpec) DeepCopyInto(out *SeccompProfileSpec) {
	*out = *in
}

func (in *SeccompProfileSpec) DeepCopy() *SeccompProfileSpec {
	if in == nil {
		return nil
	}
	out := new(SeccompProfileSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ResourceSpec) DeepCopyInto(out *ResourceSpec) {
	*out = *in
	if in.Requests != nil {
		in, out := &in.Requests, &out.Requests
		*out = make(map[string]string, len(*in))
		for k, v := range *in {
			(*out)[k] = v
		}
	}
	if in.Limits != nil {
		in, out := &in.Limits, &out.Limits
		*out = make(map[string]string, len(*in))
		for k, v := range *in {
			(*out)[k] = v
		}
	}
}

func (in *ResourceSpec) DeepCopy() *ResourceSpec {
	if in == nil {
		return nil
	}
	out := new(ResourceSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ToolPolicySpec) DeepCopyInto(out *ToolPolicySpec) {
	*out = *in
	if in.Allow != nil {
		in, out := &in.Allow, &out.Allow
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Deny != nil {
		in, out := &in.Deny, &out.Deny
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

func (in *ToolPolicySpec) DeepCopy() *ToolPolicySpec {
	if in == nil {
		return nil
	}
	out := new(ToolPolicySpec)
	in.DeepCopyInto(out)
	return out
}

// --- ClawInstance ---

func (in *ClawInstance) DeepCopyInto(out *ClawInstance) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ClawInstance) DeepCopy() *ClawInstance {
	if in == nil {
		return nil
	}
	out := new(ClawInstance)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawInstance) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClawInstanceList) DeepCopyInto(out *ClawInstanceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClawInstance, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *ClawInstanceList) DeepCopy() *ClawInstanceList {
	if in == nil {
		return nil
	}
	out := new(ClawInstanceList)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawInstanceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClawInstanceSpec) DeepCopyInto(out *ClawInstanceSpec) {
	*out = *in
	if in.Channels != nil {
		in, out := &in.Channels, &out.Channels
		*out = make([]ChannelSpec, len(*in))
		copy(*out, *in)
	}
	in.Agents.DeepCopyInto(&out.Agents)
	if in.Skills != nil {
		in, out := &in.Skills, &out.Skills
		*out = make([]SkillRef, len(*in))
		copy(*out, *in)
	}
	if in.AuthRefs != nil {
		in, out := &in.AuthRefs, &out.AuthRefs
		*out = make([]SecretRef, len(*in))
		copy(*out, *in)
	}
	if in.Memory != nil {
		in, out := &in.Memory, &out.Memory
		*out = new(MemorySpec)
		**out = **in
	}
}

func (in *ClawInstanceSpec) DeepCopy() *ClawInstanceSpec {
	if in == nil {
		return nil
	}
	out := new(ClawInstanceSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawInstanceStatus) DeepCopyInto(out *ClawInstanceStatus) {
	*out = *in
	if in.Channels != nil {
		in, out := &in.Channels, &out.Channels
		*out = make([]ChannelStatus, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *ClawInstanceStatus) DeepCopy() *ClawInstanceStatus {
	if in == nil {
		return nil
	}
	out := new(ClawInstanceStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *ChannelSpec) DeepCopyInto(out *ChannelSpec) {
	*out = *in
}

func (in *ChannelSpec) DeepCopy() *ChannelSpec {
	if in == nil {
		return nil
	}
	out := new(ChannelSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *AgentsSpec) DeepCopyInto(out *AgentsSpec) {
	*out = *in
	in.Default.DeepCopyInto(&out.Default)
}

func (in *AgentsSpec) DeepCopy() *AgentsSpec {
	if in == nil {
		return nil
	}
	out := new(AgentsSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *AgentConfig) DeepCopyInto(out *AgentConfig) {
	*out = *in
	if in.Sandbox != nil {
		in, out := &in.Sandbox, &out.Sandbox
		*out = new(SandboxSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.Subagents != nil {
		in, out := &in.Subagents, &out.Subagents
		*out = new(SubagentsSpec)
		**out = **in
	}
}

func (in *AgentConfig) DeepCopy() *AgentConfig {
	if in == nil {
		return nil
	}
	out := new(AgentConfig)
	in.DeepCopyInto(out)
	return out
}

func (in *SandboxSpec) DeepCopyInto(out *SandboxSpec) {
	*out = *in
	in.Resources.DeepCopyInto(&out.Resources)
}

func (in *SandboxSpec) DeepCopy() *SandboxSpec {
	if in == nil {
		return nil
	}
	out := new(SandboxSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SubagentsSpec) DeepCopyInto(out *SubagentsSpec) {
	*out = *in
}

func (in *SubagentsSpec) DeepCopy() *SubagentsSpec {
	if in == nil {
		return nil
	}
	out := new(SubagentsSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SkillRef) DeepCopyInto(out *SkillRef) {
	*out = *in
}

func (in *SkillRef) DeepCopy() *SkillRef {
	if in == nil {
		return nil
	}
	out := new(SkillRef)
	in.DeepCopyInto(out)
	return out
}

func (in *SecretRef) DeepCopyInto(out *SecretRef) {
	*out = *in
}

func (in *SecretRef) DeepCopy() *SecretRef {
	if in == nil {
		return nil
	}
	out := new(SecretRef)
	in.DeepCopyInto(out)
	return out
}

func (in *ChannelStatus) DeepCopyInto(out *ChannelStatus) {
	*out = *in
	if in.LastHealthCheck != nil {
		in, out := &in.LastHealthCheck, &out.LastHealthCheck
		*out = (*in).DeepCopy()
	}
}

func (in *ChannelStatus) DeepCopy() *ChannelStatus {
	if in == nil {
		return nil
	}
	out := new(ChannelStatus)
	in.DeepCopyInto(out)
	return out
}

// --- ClawPolicy ---

func (in *ClawPolicy) DeepCopyInto(out *ClawPolicy) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ClawPolicy) DeepCopy() *ClawPolicy {
	if in == nil {
		return nil
	}
	out := new(ClawPolicy)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawPolicy) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClawPolicyList) DeepCopyInto(out *ClawPolicyList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClawPolicy, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *ClawPolicyList) DeepCopy() *ClawPolicyList {
	if in == nil {
		return nil
	}
	out := new(ClawPolicyList)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawPolicyList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClawPolicySpec) DeepCopyInto(out *ClawPolicySpec) {
	*out = *in
	if in.SandboxPolicy != nil {
		in, out := &in.SandboxPolicy, &out.SandboxPolicy
		*out = new(SandboxPolicySpec)
		**out = **in
	}
	if in.SubagentPolicy != nil {
		in, out := &in.SubagentPolicy, &out.SubagentPolicy
		*out = new(SubagentPolicySpec)
		**out = **in
	}
	if in.ToolGating != nil {
		in, out := &in.ToolGating, &out.ToolGating
		*out = new(ToolGatingSpec)
		(*in).DeepCopyInto(*out)
	}
	if in.FeatureGates != nil {
		in, out := &in.FeatureGates, &out.FeatureGates
		*out = make(map[string]bool, len(*in))
		for k, v := range *in {
			(*out)[k] = v
		}
	}
	if in.NetworkPolicy != nil {
		in, out := &in.NetworkPolicy, &out.NetworkPolicy
		*out = new(NetworkPolicySpec)
		(*in).DeepCopyInto(*out)
	}
}

func (in *ClawPolicySpec) DeepCopy() *ClawPolicySpec {
	if in == nil {
		return nil
	}
	out := new(ClawPolicySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawPolicyStatus) DeepCopyInto(out *ClawPolicyStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *ClawPolicyStatus) DeepCopy() *ClawPolicyStatus {
	if in == nil {
		return nil
	}
	out := new(ClawPolicyStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *SandboxPolicySpec) DeepCopyInto(out *SandboxPolicySpec) {
	*out = *in
}

func (in *SandboxPolicySpec) DeepCopy() *SandboxPolicySpec {
	if in == nil {
		return nil
	}
	out := new(SandboxPolicySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SubagentPolicySpec) DeepCopyInto(out *SubagentPolicySpec) {
	*out = *in
}

func (in *SubagentPolicySpec) DeepCopy() *SubagentPolicySpec {
	if in == nil {
		return nil
	}
	out := new(SubagentPolicySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ToolGatingSpec) DeepCopyInto(out *ToolGatingSpec) {
	*out = *in
	if in.Rules != nil {
		in, out := &in.Rules, &out.Rules
		*out = make([]ToolGatingRule, len(*in))
		copy(*out, *in)
	}
}

func (in *ToolGatingSpec) DeepCopy() *ToolGatingSpec {
	if in == nil {
		return nil
	}
	out := new(ToolGatingSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ToolGatingRule) DeepCopyInto(out *ToolGatingRule) {
	*out = *in
}

func (in *ToolGatingRule) DeepCopy() *ToolGatingRule {
	if in == nil {
		return nil
	}
	out := new(ToolGatingRule)
	in.DeepCopyInto(out)
	return out
}

func (in *NetworkPolicySpec) DeepCopyInto(out *NetworkPolicySpec) {
	*out = *in
	if in.AllowedEgress != nil {
		in, out := &in.AllowedEgress, &out.AllowedEgress
		*out = make([]EgressRule, len(*in))
		copy(*out, *in)
	}
}

func (in *NetworkPolicySpec) DeepCopy() *NetworkPolicySpec {
	if in == nil {
		return nil
	}
	out := new(NetworkPolicySpec)
	in.DeepCopyInto(out)
	return out
}

func (in *EgressRule) DeepCopyInto(out *EgressRule) {
	*out = *in
}

func (in *EgressRule) DeepCopy() *EgressRule {
	if in == nil {
		return nil
	}
	out := new(EgressRule)
	in.DeepCopyInto(out)
	return out
}

// --- SkillPack ---

func (in *SkillPack) DeepCopyInto(out *SkillPack) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

func (in *SkillPack) DeepCopy() *SkillPack {
	if in == nil {
		return nil
	}
	out := new(SkillPack)
	in.DeepCopyInto(out)
	return out
}

func (in *SkillPack) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *SkillPackList) DeepCopyInto(out *SkillPackList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SkillPack, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *SkillPackList) DeepCopy() *SkillPackList {
	if in == nil {
		return nil
	}
	out := new(SkillPackList)
	in.DeepCopyInto(out)
	return out
}

func (in *SkillPackList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *SkillPackSpec) DeepCopyInto(out *SkillPackSpec) {
	*out = *in
	if in.Skills != nil {
		in, out := &in.Skills, &out.Skills
		*out = make([]Skill, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RuntimeRequirements != nil {
		in, out := &in.RuntimeRequirements, &out.RuntimeRequirements
		*out = new(RuntimeRequirements)
		**out = **in
	}
	if in.Sidecar != nil {
		in, out := &in.Sidecar, &out.Sidecar
		*out = new(SkillSidecar)
		(*in).DeepCopyInto(*out)
	}
}

func (in *SkillPackSpec) DeepCopy() *SkillPackSpec {
	if in == nil {
		return nil
	}
	out := new(SkillPackSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *SkillPackStatus) DeepCopyInto(out *SkillPackStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *SkillPackStatus) DeepCopy() *SkillPackStatus {
	if in == nil {
		return nil
	}
	out := new(SkillPackStatus)
	in.DeepCopyInto(out)
	return out
}

func (in *Skill) DeepCopyInto(out *Skill) {
	*out = *in
	if in.Requires != nil {
		in, out := &in.Requires, &out.Requires
		*out = new(SkillRequirements)
		(*in).DeepCopyInto(*out)
	}
}

func (in *Skill) DeepCopy() *Skill {
	if in == nil {
		return nil
	}
	out := new(Skill)
	in.DeepCopyInto(out)
	return out
}

func (in *SkillRequirements) DeepCopyInto(out *SkillRequirements) {
	*out = *in
	if in.Bins != nil {
		in, out := &in.Bins, &out.Bins
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Tools != nil {
		in, out := &in.Tools, &out.Tools
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

func (in *SkillRequirements) DeepCopy() *SkillRequirements {
	if in == nil {
		return nil
	}
	out := new(SkillRequirements)
	in.DeepCopyInto(out)
	return out
}

func (in *RuntimeRequirements) DeepCopyInto(out *RuntimeRequirements) {
	*out = *in
}

func (in *RuntimeRequirements) DeepCopy() *RuntimeRequirements {
	if in == nil {
		return nil
	}
	out := new(RuntimeRequirements)
	in.DeepCopyInto(out)
	return out
}

func (in *SkillSidecar) DeepCopyInto(out *SkillSidecar) {
	*out = *in
	if in.Command != nil {
		in, out := &in.Command, &out.Command
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Env != nil {
		in, out := &in.Env, &out.Env
		*out = make([]EnvVar, len(*in))
		copy(*out, *in)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(SidecarResources)
		**out = **in
	}
	if in.RBAC != nil {
		in, out := &in.RBAC, &out.RBAC
		*out = make([]RBACRule, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ClusterRBAC != nil {
		in, out := &in.ClusterRBAC, &out.ClusterRBAC
		*out = make([]RBACRule, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *SkillSidecar) DeepCopy() *SkillSidecar {
	if in == nil {
		return nil
	}
	out := new(SkillSidecar)
	in.DeepCopyInto(out)
	return out
}

func (in *EnvVar) DeepCopyInto(out *EnvVar) {
	*out = *in
}

func (in *EnvVar) DeepCopy() *EnvVar {
	if in == nil {
		return nil
	}
	out := new(EnvVar)
	in.DeepCopyInto(out)
	return out
}

func (in *SidecarResources) DeepCopyInto(out *SidecarResources) {
	*out = *in
}

func (in *SidecarResources) DeepCopy() *SidecarResources {
	if in == nil {
		return nil
	}
	out := new(SidecarResources)
	in.DeepCopyInto(out)
	return out
}

func (in *RBACRule) DeepCopyInto(out *RBACRule) {
	*out = *in
	if in.APIGroups != nil {
		in, out := &in.APIGroups, &out.APIGroups
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Verbs != nil {
		in, out := &in.Verbs, &out.Verbs
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

func (in *RBACRule) DeepCopy() *RBACRule {
	if in == nil {
		return nil
	}
	out := new(RBACRule)
	in.DeepCopyInto(out)
	return out
}

// --- ClawSchedule ---

func (in *ClawSchedule) DeepCopyInto(out *ClawSchedule) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	out.Spec = in.Spec
	in.Status.DeepCopyInto(&out.Status)
}

func (in *ClawSchedule) DeepCopy() *ClawSchedule {
	if in == nil {
		return nil
	}
	out := new(ClawSchedule)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawSchedule) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClawScheduleList) DeepCopyInto(out *ClawScheduleList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ClawSchedule, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *ClawScheduleList) DeepCopy() *ClawScheduleList {
	if in == nil {
		return nil
	}
	out := new(ClawScheduleList)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawScheduleList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

func (in *ClawScheduleSpec) DeepCopyInto(out *ClawScheduleSpec) {
	*out = *in
}

func (in *ClawScheduleSpec) DeepCopy() *ClawScheduleSpec {
	if in == nil {
		return nil
	}
	out := new(ClawScheduleSpec)
	in.DeepCopyInto(out)
	return out
}

func (in *ClawScheduleStatus) DeepCopyInto(out *ClawScheduleStatus) {
	*out = *in
	if in.LastRunTime != nil {
		in, out := &in.LastRunTime, &out.LastRunTime
		*out = (*in).DeepCopy()
	}
	if in.NextRunTime != nil {
		in, out := &in.NextRunTime, &out.NextRunTime
		*out = (*in).DeepCopy()
	}
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]metav1.Condition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

func (in *ClawScheduleStatus) DeepCopy() *ClawScheduleStatus {
	if in == nil {
		return nil
	}
	out := new(ClawScheduleStatus)
	in.DeepCopyInto(out)
	return out
}

// --- MemorySpec ---

func (in *MemorySpec) DeepCopyInto(out *MemorySpec) {
	*out = *in
}

func (in *MemorySpec) DeepCopy() *MemorySpec {
	if in == nil {
		return nil
	}
	out := new(MemorySpec)
	in.DeepCopyInto(out)
	return out
}
